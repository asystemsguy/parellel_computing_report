
\section{Related Work}

Jouili and Vansteenberghe ~\cite{jouili2013empirical} compared four major graph databases: Neo4j, OrientDB, Titan, and DEX, based on their runtime of shortest path, breadth first search and other read and write workloads such as reading and updating vertices. They found that Neo4j outperforms all other databases in case of traversal workload, all four DBs perform similar in case of read only workload and DEX performs better for read-write workloads.

Vicknair et al.~\cite{vicknair2010comparison} compared relational database(MySql) with a graph database (Neo4j) for traversal queries and read queries and found that Neo4j has much better execution time in all the traversal queries and most of the read queries. They also compated those databases on the basis of the subjective measures such as maturity and level of support, ease of programming, flexibility,
and security.

Holzschuher and Peinl ~\cite{holzschuher2013performance} made comparison of graph query languages such as, Cypher, Gremlin, and Native Access in Neo4j.  
McColl et al.~\cite{mccoll2014performance} performed qualitative and performance comparison study on 12 open source graph databases including Neo4j and OrientDB. For the performance comparison, they ran four graph algorithms: Single Source Shortest Path (SSSP), Connected Components, PageRank (PR), and Update on graphs of different sizes i.e. tiny, small, medium, and large. Their results show that Neo4j out-performs Orient DB in case of SSSP and Connected Components, whereas Orient DB is better at running PageRank and update algorithms on the graph of small size.

Kolomiƒçenko et al.~\cite{kolomivcenko2013experimental} also compared the performance of the 8 different graph databases for the graph loading operation, traversal queries, vertex and edges read and write queries. They conclude that also find that Neo4j and DEX outperform the other databases for most the database queries. These papers compared the graph databases on the traversal, read and write queries whereas our work compared the performance of the graph databases on the basis of pattern matching capabilities.

Hong et al.~\cite{hong2016evaluation} evaluated the graph pattern matching capabilities of six graph analysis systems: standalone systems (Neo4j, NetworkX, and Jena), distributed systems (GraphX and Titan), and shared-memory system (uRiKA) on the sythetic graphs for nine different pattern matching queries. They conclude that not a single system has best performance for their different pattern matching queries. From their experience, they also suggest that Cypher and SPARQL have the best expressiveness for graph pattern matching and Gremlin has several limitations on expressing graph pattern queries. They never managed to load graph size similar to ours without crashing on two standalone graph databases (Neo4j and titan) for all queries. The query for each database is wrote in its own language, while in our project, we used a common query implementation using gremlin-python standard to test databases. 

% Reza et al.~\cite{reza2018prunejuice} developed new algorithmic pipeline to support pattern matching on large-scale metadata graphs on large distributed-memory machines. Their main ideas are graph pruning and develop asynchronous algorithms that use both vertex and edge elimination to iteratively prune the original graph and reduce it to a subgraph which represents the union of all matches. They evaluated their approach on 257 billion edge real-world web-graphs and up to 4.4 trillion edge synthetic R-MAT graphs. 
% Tripoul et al.~\cite{tripoulthere} developed a highly scalable algorithmic pipeline for pattern matching in labeled graphs and demonstrated it on trillion-edge graphs using a prototype shared-memory implementation. They use a number of ad-hoc intuition-based heuristics for constraint selection, ordering, and generation. We referred the pattern matching queries from ~\cite{reza2018prunejuice} and ~\cite{tripoulthere}  for IMDB dataset in our experiment to compare the graph databases.
